[[cls-10c-5]]
== HDF5 Specification

HDF5 implements a model for managing and storing data. The model includes
an abstract data model and an abstract storage model (the data format), and
libraries to implement the abstract model and to map the storage model to
different storage mechanisms. The HDF5 library provides a programming
interface to a concrete implementation of the abstract models. The library
also implements a model of data transfer; that is, efficient movement of
data from one stored representation to another stored representation.
<<fig-10c-1>> illustrates the relationships between the models and
implementations.

[[fig-10c-1]]
.HDF5 models and implementation
image::img152.png[]

The _Abstract Data Model_ is a conceptual model of data, data types, and
data organization. The abstract data model is independent of storage medium
or programming environment. The _Storage Model_ is a standard
representation for the objects of the abstract data model. The _HDF5 File
Format Specification_ defines the storage model.

The _Programming Model_ is a model of the computing environment and
includes platforms from small single systems to large multiprocessors and
clusters. The programming model manipulates (instantiates, populates, and
retrieves) objects from the abstract data model.

The _Library_ is the concrete implementation of the programming model. The
Library exports the HDF5 APIs as its interface. In addition to implementing
the objects of the abstract data model, the Library manages data transfers
from one stored form to another. Data transfer examples include reading
from disk to memory and writing from memory to disk.

_Stored Data_ is the concrete implementation of the storage model. The
storage model is mapped to several storage mechanisms including single disk
files, multiple files (family of files), and memory representations.

The HDF5 Library is a C module that implements the programming model and
abstract data model. The HDF5 Library calls the operating system or other
storage management software (e.g., the MPI/IO Library) to store and
retrieve persistent data. The HDF5 Library may also link to other software
such as filters for compression. The HDF5 Library is linked to an
application program which may be written in C, C++, Fortran, or Java. The
application program implements problem specific algorithms and data
structures and calls the HDF5 Library to store and retrieve data.

The HDF5 Library implements the objects of the HDF5 abstract data model.
Some of these objects include groups, datasets, and attributes. An S-100
Product Specification maps the S-100 data structures to a hierarchy of HDF5
objects. Each S-100-based Product Specification will create a mapping best
suited to its purposes.

The objects of the HDF5 abstract data model are mapped to the objects of
the HDF5 storage model, and stored in a storage medium. The stored objects
include header blocks, free lists, data blocks, B-trees, and other objects.
Each group or dataset is stored as one or more header and data blocks.

[[cls-10c-5.1]]
=== Abstract Data Model

The abstract data model (ADM) defines concepts for defining and describing
complex data stored in files. The ADM is a very general model which is
designed to conceptually cover many specific models. Many different kinds
of data can be mapped to objects of the ADM, and therefore stored and
retrieved using HDF5. The ADM is not, however, a model of any particular
problem or application domain. Users need to map their data to the concepts
of the ADM.

The key concepts include:

* _File_ - a contiguous string of bytes in a computer store (memory, disk,
etc), and the bytes represent zero or more objects of the model;
* _Group_ - a collection of objects (including groups);
* _Dataset_ - a multidimensional array of data elements with attributes and
other metadata;
* _Dataspace_ - a description of the dimensions of a multidimensional array;
* _Datatype_ - a description of a specific class of data element including
its storage layout as a pattern of bits;
* _Attribute_ - a named data value associated with a group, dataset, or
named datatype;
* _Property List_ - a collection of parameters (some permanent and some
transient) controlling options in the library;
* _Link_ - the way objects are connected.

These key concepts are described in more detail below.

[[cls-10c-5.1.1]]
==== File

Abstractly, an HDF5 file is a container for an organized collection of
objects. The objects are groups, datasets, and other objects as defined
below. The objects are organized as a rooted, directed graph. Every HDF5
file has at least one object, the root group. See <<fig-10c-2>>. All
objects are members of the root group or descendents of the root group.

HDF5 objects have a unique identity _within a single HDF5 file_ and can be
accessed only by its names within the hierarchy of the file. HDF5 objects
in different files do not necessarily have unique identities, and it is not
possible to access a permanent HDF5 object except through a file.

When the file is created, the _file creation properties_ specify settings
for the file. The file creation properties include version information and
parameters of global data structures. When the file is opened, the _file
access properties_ specify settings for the current access to the file.
File access properties include parameters for storage drivers and
parameters for caching and garbage collection. The file creation properties
are set permanently for the life of the file, and the file access
properties can be changed by closing and reopening the file.

An HDF5 file can be "mounted" as part of another HDF5 file. This is
analogous to Unix file system mounts. The root of the mounted file is
attached to a group in the mounting file, and all the contents can be
accessed as if the mounted file were part of the mounting file.

[[cls-10c-5.1.2]]
==== Group

An HDF5 group is analogous to a file system directory. Abstractly, a group
contains zero or more objects, and every object must be a member of at
least one group. The root group is a special case; it may not be a member
of any group.

Group membership is actually implemented via link objects. See
<<fig-10c-2>>. A link object is owned by a group and points to a named
object. Each link has a name, and each link points to exactly one object.
Each named object has at least one and possibly many links to it.

[[fig-10c-2]]
.Group membership via link objects
image::img153.png[]

There are three classes of named objects: group, dataset, and named
datatype. See <<fig-10c-3>>. Each of these objects is the member of at
least one group, and this means there is at least one link to it.

[[fig-10c-3]]
.Classes of named objects
image::img154.png[]

[[cls-10c-5.1.3]]
==== Dataset

An HDF5 dataset is a multidimensional array of data elements. See
<<fig-10c-4>>. The shape of the array (number of dimensions, size of each
dimension) is described by the dataspace object.

A data element is a single unit of data which may be a number, a character,
an array of numbers or characters, or a record of heterogeneous data
elements. A data element is a set of bits. The layout of the bits is
described by the datatype.

The dataspace and datatype are set when the dataset is created, and they
cannot be changed for the life of the dataset. The dataset creation
properties are set when the dataset is created. The dataset creation
properties include the fill value and storage properties such as chunking
and compression. These properties cannot be changed after the dataset is
created.

The dataset object manages the storage and access to the data. While the
data is conceptually a contiguous rectangular array, it is physically
stored and transferred in different ways depending on the storage
properties and the storage mechanism used. The actual storage may be a set
of compressed chunks, and the access may be through different storage
mechanisms and caches. The dataset maps between the conceptual array of
elements and the actual stored data.

[[fig-10c-4]]
.The dataset
image::img155.png[]

[TIP,type=box]
====
The HDF5 concept of 'dataset' means an array, while the S-100 concept is
defined as "an identifiable collection of data" (S-100 Annex A -- Terms and
Definitions) which is generally interpreted to mean a collection of
instances of feature and/or information type.

This Part frequently uses the terms "data file" to mean a dataset in the
S-100 sense and "HDF5 dataset" to mean a dataset in the HDF sense. Where
these terms are not used, the sense should be apparent from the context.
====

[[cls-10c-5.1.4]]
==== Dataspace

The HDF5 dataspace describes the layout of the elements of a
multidimensional array. Conceptually, the array is a hyper-rectangle with
one to 32 dimensions. HDF5 dataspaces can be extendable. Therefore, each
dimension has a current size and a maximum size, and the maximum may be
unlimited. The dataspace describes this hyper-rectangle: it is a list of
dimensions with the current and maximum (or unlimited) sizes.

[[cls-10c-5.1.5]]
==== DataType

The HDF5 datatype object describes the layout of a single data element. A
data element is a single element of the array; it may be a single number, a
character, an array of numbers or carriers, or other data. The datatype
object describes the storage layout of this data.

Data types are categorized into 11 classes of datatype. Each class is
interpreted according to a set of rules and has a specific set of
properties to describe its storage. For instance, floating point numbers
have exponent position and sizes which are interpreted according to
appropriate standards for number representation. Thus, the datatype class
tells what the element means, and the datatype describes how it is stored.

<<fig-10c-5>> shows the classification of datatypes. Atomic datatypes are
indivisible. Each may be a single object; a number, a string, or some other
objects. Composite datatypes are composed of multiple elements of atomic
datatypes. In addition to the standard types, users can define additional
datatypes such as a 24-bit integer or a 16-bit float.

A dataset or attribute has a single datatype object associated with it. See
<<fig-10c-4>> above. The datatype object may be used in the definition of
several objects, but by default, a copy of the datatype object will be
private to the dataset.

Optionally, a datatype object can be stored in the HDF5 file. The datatype
is linked into a group, and therefore given a name. A _named datatype_ can
be opened and used in any way that a datatype object can be used.

Not all the HDF5 datatypes have exact equivalents in the S-100 basic and
derived datatypes defined in Part 1, clause 1-4.5.2 (Table 1-2). The
correspondences between HDF5 and S-100 datatypes are given in Table 10c-2
later in this Part.

[[fig-10c-5]]
.Datatype classifications
image::img156.png[]

[[cls-10c-5.1.6]]
==== Attribute

Any HDF5 named data object (group, dataset, or named datatype) may have
zero or more user defined attributes. Attributes are used to document the
object. The attributes of an object are stored with the object.

An HDF5 attribute has a name and data. The data portion is similar in
structure to a dataset: a dataspace defines the layout of an array of data
elements, and a datatype defines the storage layout and interpretation of
the elements. See <<fig-10c-6>> below.

Attributes of data objects are in principle equivalent to thematic
attributes but this edition of the HDF5 profile does not provide for vector
feature or information type data in HDF5 files and therefore does not make
use of vector object attributes. HDF5 attributes of groups, datasets, or
named datatypes play the role of metadata.

[[fig-10c-6]]
.Attribute data elements
image::img157.png[]

In fact, an attribute is very similar to a dataset with the following
limitations:

* An attribute can only be accessed via the object;
* Attribute names are significant only within the object;
* An attribute should be a small object;
* The data of an attribute must be read or written in a single access
(partial reading or writing is not allowed);
* Attributes do not have attributes.

Note that the value of an attribute can be an _object reference_. A shared
attribute or an attribute that is a large array can be implemented as a
reference to a dataset.

The name, dataspace, and datatype of an attribute are specified when it is
created and cannot be changed over the life of the attribute. An attribute
can be opened by name, by index, or by iterating through all the attributes
of the object.

[[cls-10c-5.1.7]]
==== Property List

HDF5 has a generic property list object. Each list is a collection of
_name-value_ pairs. Each class of property list has a specific set of
properties. Each property has an implicit name, a datatype, and a value. A
property list object is created and used in ways similar to the other
objects of the HDF5 library.

Property Lists are attached to the object in the library, they can be used
by any part of the library. Some properties are permanent (e.g., the
chunking strategy for a dataset), others are transient (for example buffer
sizes for data transfer). A common use of a Property List is to pass
parameters from the calling program to a VFL driver or a module of the
pipeline.

Property lists are conceptually similar to attributes. Property lists are
information relevant to the behavior of the library while attributes are
relevant to the user's data and application. Since the Property List
couples the data specification to an implementation use of HDF5 property
lists in S-100 Product Specifications is discouraged.

[[cls-10c-5.2]]
=== HDF5 Library and Programming Model

The HDF5 Library implements the HDF5 abstract data model and storage model.
Two major objectives of the HDF5 products are to provide tools that can be
used on as many computational platforms as possible (portability), and to
provide a reasonably object-oriented data model and programming interface.

Refer to the HDF5 User's Guide Release 1.8.8 and the HDF5 Reference Manual
1.8.8 for more details on the HDF5 model implementation. S-100 Product
Specifications must specify the HDF5 groups, datasets and attributes in
context of the S-100 General Feature Model.

[[cls-10c-5.3]]
=== Prohibited HDF5 constructs

Constructs which cannot be processed using the standard libraries of the
HDF5 release specified in this Part must not be used. This means
specifically that HDF5 constructs which require the use of a library for a
later release than that specified in this Part must not be used.
